###############
# Introduction
###############
- where can we find distributed systems
watch a movie on demand
shop online
order a ride share service through our mobile
search for something online

- companies running highly scalable distributed systems to:
handle millions of users
Petabytes of data
provide consistent user experience

- Cloud (AWS, Azure, GCP, etc) is a distributed system designed for companies and software developers


# Evolution of a small software startup company
- example:
John creates an awesome website + mobile app to purchase computer products and share the reviews with friends / users
He creates that website in his laptop and mobile with a webserver computer as the backend webserver / disk
As the user base grows, the computer can't handle and performance degrades
John upgrades his computer - vertical scaling
However, more users still hit the limits of the computer
Also single point of failure - if computer goes down - everything stops
High latency for users who are far away in other countries / continents
Security and Privacy may also be breached easily

- Solution: Distributed System
A Distributed System is a system of several processes, running on different computers,
 communicating with each other through the network,
 and are sharing a state
 or are working together to achieve a common goal

- What is a Process
Any application / jar running in computer's memory

# Inter-process communication (same machine)
- processes communicating to each other via:
File System (hard disk)
Memory

- not a distributed system

# Decoupling of processes
- run each process on different computers
- horizontal scaling - adding more machines
- network communication between machines
- sharing state and working toward a common goal => no common goal - not a distributed system


##########################################################
# Cluster Coordination Service and Distributed Algorithms
##########################################################

## Introduction to Cluster Coordination & Theory of Leader Election

# Terminology
- Node
a process running on a dedicated machine
can communicate with each other on a network

- Cluster
collection of computer/nodes connected to each other
the nodes in a cluster are working on the same task and typically are running the same code


# Design our first disributed algorithm
- how to hand a task to a Cluster
- how to break the work among nodes

# Attempt 1 - manual distribution
- define each node a separate task manually
- but thousands of tasks received per second - impossible to manually distribute it

# Attempt 2 - manually elect a leader
- a leader node decides and distributes (programatically) tasks amongs nodes
- but single point of failure if leader node is down

# Attempt 3 - automatic leader election
- algorithm to elect leader and monitor the health
- failure detection -> re-election of new leader
- joining of old leader after recovery

# challenges of leader/master -> workers architecture
- automatic and system leader election is not a trivial task to solve, even among people
- arriving to an agreement on a leader in a large cluster of nodes is even harder
- by default, each node knows only about itself - thus, service registry and discovery is required
- failure detection mechanism is necessary to trigger automatic leader re-election in a cluster

# Master-Workers coordinaton solution
- implement distributed algorithms for consensus and failover from scratch
- Apache Zookeeper - high performance distributed system coordination service


###################
# Apache Zookeeper
###################
- a high performance coordination service designed specifically for distributed systems
- popular technology used by many companies and projects (Kafka, Hadoop, HBase, etc)
- provides an abstraction layer for higher level distributed algorithms

# what makes Zookeeper a good solution?
- is a distributed system itself that provides us high availability and reliability
- typically runs in a cluster of an odd number of nodes, higher than 3
- uses redundancy to allow failures and stay functional

# Zookeeper properties
- Zookeeper's abstraction and data model is very much similar to a file system - root node and directories / subdirectories / files
- each node in a Zookeeper is called Znodes
- Znodes:
hybrid between a file and a directory
Znodes can store any data inside - like a file
Znodes can have children Znodes - like a directory

- two types of Znodes:
persistent: persists between sessions
ephermal: is deleted when the session ends

- An Ephermal Znode is deleted automatically as soon as its creator process disconnects from zookeeper
this can help to detect that a process dies or disconnected from the zookeeper service

- a Persisten Znode stays within Zookeeper until it is explicitly deleted
this can help to store data in between sessions


## Leader election algorithn
Step 1:
- every node connects to Zookeeper and creates its Znode under Zookeeper's Znode = /election
- zookeeper gives a unique number to each new Znode in the order of their addition
Step 2:
- each node will query the children of /election
- it's guaranteed that node will receive all the children Znodes which were created "prior" to its own Znode
Step 3:
- if no children received, then the current node is the first one and becomes the leader
- elected based on lower number priority or some other algorithm
- if not the leader - it will follow the instructions from leader as the leader will already be elected

summary:
Each node in the cluster will try to create a znode with the lowest sequence number available as the znode's name
When a node detects that its znode has the lowest sequence number, it becomes the leader
When a node detects that its znode doesn't have the lowest sequence number, it becomes the follower
Zookeeper guarantees a monotonically increasing, unique sequence number for each node that requests a sequence suffixed znode


## resources
https://blog.twitter.com/engineering/en_us/topics/infrastructure/2018/zookeeper-at-twitter
https://zookeeper.apache.org/doc/r3.7.0/index.html


## Zookeeper Server and Client - Download and setup
- Zookeeper configuration and startup
- Zookeeper command line client
- development done locally on a single computer but deploy to production cluster
- Zookeeper client makes Znodes appear like files on our computer
however, there are no Znodes stored in our file system - it's a representation of the zookeeper in-memory data model

- download:
https://zookeeper.apache.org/releases.html
https://www.apache.org/dyn/closer.lua/zookeeper/zookeeper-3.7.0/apache-zookeeper-3.7.0-bin.tar.gz

- configuration:
create a new folder as logs/
rename conf/zoo.cfg
change dataDir to point to logs/

- run:
start server
./bin/zkServer.sh start
./bin/zkServer.sh status

start client
./bin/zkCli.sh

- client command line - can type commands here
help
ls / => total znodes available
create /parent "some parent data" => create parent znode
create /parent/child "some child data" => create child znode
set /parent/child "got new data" => data changed
ls /parent
get /parent => info about parent znode
delete /parent
deleteall /parent
create /election ""


## Zookeeper threading model
- application start code in the main method is executed on the main thread
- when Zookeeper object is created, 2 additional threads are created:
event thread
IO thread

# IO Thread
- handles all the network communication with Zookeeper servers
- handles Zookeeper requests and responses
- responds to pings
- session management
- session timeouts
- etc.

# Event Thread
- manages Zookeeper events
  connection (KeeperState.SyncConnected)
  disconnection (KeeperState.Disconnected)
- custom znode Watchers and Triggers to subscribe to
- Events are executed on Event Thread in order

- demo code: LeaderElection

- when the Zookeeper client connects to Zookeeper server - as its all asynchronous and event driven
server will respond the events in the separate event threads
thus client needs to implement Watcher and use event handlers to handle WatchedEvent in overridden process() method
- for successful connection - server sends event of type None and state as Event.KeeperState.SyncConnected
- server also keeps on sending ping to check if the client is alive and connected
- client maintains a background IO thread that has to send and respond to pings to and from server
- if the server is down after successful connection, the event state will change and then client can close the connection

- to package the code, need maven plugin: maven-assembly-plugin
- then run: mvn clean package
- execute 4 nodes in 4 git bash
java -jar target/leader.election-1.0-SNAPSHOT-jar-with-dependencies.jar


## Watchers and Triggers
- we can register a watcher when we call the methods
getChildren() - get notified when the list of a znode's children changes
getData() - get notified if a znode's data gets modified
exists() - get notified if a znode gets deleted or created

- watcher allows us to get a notifcation when a change happens
- demo code: WatchersDemo


## Leader Re-election
- for reelection of leader, instead of all cluster nodes "watching" the znodes
only the next cluster node watches the previous ephermal znode
if the leader cluster node dies, its znode will send the deleted node event to the next cluster node
and next cluster node will become the new leader

- demo code: LeaderReelection

## Fault Tolerance and Horizontal Scalability are very important properties
- Fault Tolerance: business can run 24X7 with no interruptions
- Horizontal Scalability: can dynamically grow our business on demand


## Auto-healer
- In cloud computing, auto-healing is a feature used to monitor a cluster and detect faulty application instances
- If a faulty instance is detected, the node is shut down and a new node is created with a healthy application instance

java -jar target/autohealer-1.0-SNAPSHOT-jar-with-dependencies.jar 10 "../flakyworker/target/flaky.worker-1.0-SNAPSHOT-jar-with-dependencies.jar"
java -jar .\target\autohealer-1.0-SNAPSHOT-jar-with-dependencies.jar 10 "..\flakyworker\target\flaky.worker-1.0-SNAPSHOT-jar-with-dependencies.jar"
C:\Users\rishi\Downloads\Study\Udemy\Design Patterns\distributed-systems\leader.election\flakyworker\target\flaky.worker-1.0-SNAPSHOT-jar-with-dependencies.jar


## Service Discovery
- nodes should know which other nodes are present in the cluster
- use dynamic configuration tool like Chef or Puppet to distribute among the nodes
- best to use service registry in Zookeeper
- other techs: etcd, consul, Netflix Eureka, etc...

## Service Registry with Zookeeper
- each node will create an ephermal Znode with its address in it with permanent Znode /service_registry as ephermal Znode's parent
- then any node can call getChildren() on /service_registry to get all ephermal Znodes
- and use getData() method on ephermal Znode to get the address

## pending - demo code


########################
# Network Communication
########################
- in the same java process, all the threads communicate with each other using same shared memory
- in the distributed systems, communication between nodes is different as there is no shared memory




